To add a key exchange scheme, the programmer must first implement the desired cryptosystem according to the interface:

typedef struct {
    dh_type_t type;
    const char *name;

    void *(*ctx_alloc)( void );
    void (*ctx_free)( void *ctx );

    int (*gen_public)( void *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng );
    int (*compute_shared)( void *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng );

    int (*set_params)( void *ctx, const void *params );
    int (*read_ske_params)( void *ctx, int *rlen, const unsigned char *buf, size_t blen );
    int (*read_public)( void *ctx, const unsigned char *buf, size_t blen );

    /* A "pk_ctx" represents an interface with a certificate
     * which is initialized in pk_parse_subpubkey() in library/pkparse.c */
    int (*read_from_self_pk_ctx)( void *ctx, const void *pk_ctx );
    int (*read_from_peer_pk_ctx)( void *ctx, const void *pk_ctx );

    size_t (*getsize_ske_params)( const void *ctx );
    int (*write_ske_params)( size_t *olen, unsigned char *buf, size_t blen, const void *ctx );
    size_t (*getsize_public)( const void *ctx );
    int (*write_public)( size_t *olen, unsigned char *buf, size_t blen, const void *ctx );
    size_t (*getsize_premaster)( const void *ctx );
    int (*write_premaster)( size_t *olen, unsigned char *buf, size_t blen, const void *ctx );
} dh_info2_t;


The functions will be executed in the following order:

		server								client

	ctx_alloc								ctx_alloc
	set_params
	gen_public
	getsize_ske_params
	write_ske_params
								------>
						(unsigned char *buf)		
											read_ske_params
											gen_public
											getsize_public
											write_public
								<------
						(unsigned char *buf)		
	compute_shared					compute_shared
	getsize_premaster					getsize_premaster
	write_premaster					write_premaster
	ctx_free								ctx_free

ctx_alloc:
	This function allocates the programmer-defined context, and is send to each of the consequent function implementation.
There is no restriction to the content of the context.

ctx_free:
	This function frees the content of the programmer-defined context, and is called after the key exchange ends, or should any error occurs.

set_params:
	On server side, one should set all parameters in the context here. It is possible to take parameter form upper layer, but it is not currently
implemented in polarssl, so the params argument is always NULL.

gen_public:
	The main computation should take place here, such as g^a in the Diffie-Hellman scheme. Note that this function is executed at both side of 
the exchange, but at different timing.
	The f_rng argument is a random number generator, with first argement its state, second argument the buffer to be randomized, 
third argument the buffer length. When using, one should pass p_rng to f_rng as the first argument.

getsize_ske_params:
write_ske_params:
	ske_param denotes every data one need to pass to the client side. The getsize function requires the size returned in byte. 
	In write_ske_params,  one should write these data to buf. blen denotes the size of buf, and one should write the actual byte
written in olen.

read_ske_params:
	The clients reads data from buf, which is exactly what is written in write_ske_params. blen denotes the size of buf, and one should
 write the actual byte read in rlen.

	
getsize_public:
write_public:
read_public:
	these functions are the counterpart of
	getsize_ske_params
	write_ske_params
	read_ske_params
	The explaination is omitted, the only difference is that one does not need to report rlen in read_public.

compute_shared:
	Computes the shared secret, the main computation should take place here, such as (g^a)^b in the Diffie-Hellman scheme. 
	The argument is that same as gen_public.

getsize_premaster:
	Returns the size of the shared secret.

write_premaster
	Write the shared secret into buf.


After the implementation, one should do the following to merge the implemented scheme into polarssl.
	In dh_wrap.h, add the newly implemented interface so the rest of the code can properly recognize it.
	In ssl.h, make sure SSL_BUFFER_LEN is large enough for the communication. Also, add elements 
in union _ssl_premaster_secret to make sure the size is large enough for premaster. 
	In ssl_tls.c, ssl_srv.c, ssl_cli.c, include your header.


After all of these, the new KE should work.





-------------------------------------------------------------------





After adding a new key exchange protocal and/or public key authentication protocal, one should conbine 
them into a ciphersuite for user usage. To do this, the following changes should be made:
	 
In ssl_ciphersuite.h, define the new ciphersuite, also add it to the enum key_exchange_type_t.
In ssl_ciphersuite.c, add the new ciphersuite definition to ciphersuite_definitions and key_agree_definitions.




	 








