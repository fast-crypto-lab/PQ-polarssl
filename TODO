Meeting Notes 7/17 14:26
------------------------

今天 trace 了 PolarSSL 的 SSL handshake 當中 DH keyexchange 部分，
覺得有很多程式碼相當 dirty 而且不容易清理。

1. 加一個 DH 抽象層
2. 把現有的 DH 與 ECDH 程式碼用我們的抽象層包裝起來
   (測試 DH standalone testcase 要通過)
3. 修改 SSL structure, 要加上我們的抽象層
4. 把呼叫 DH 與 ECDH 的程式碼 (主要在 handshaking 部分中)
   換成我們的寫法

Next internal meeting date: 7/21 (一) 早上 10:00 @MD631



Meeting Notes 7/21 13:55
------------------------

今日再看了一次 DH 與 ECDH 的上下層包裝實作方式,
然後簡單地撰寫了 DHM 的我們的包裝...

TODO 分工表:
1-1. Wrap EECDH using our wrapper (the same procedure as ddhm_...)
1-2. Write testsuite for EECDH
2-1. The ddhm_init need to set P and G
2-2. Write testsuite for DDHM
3. Read SSL codes (how does it use the crypto wrapper?)

Next internal meeting date: 7/24 Thu (or 7/25 Fri) 10:00 am @MD631

To be disscussed:
1. buffer length of DH.
2. Currently the only one wrapper for ECDH does not specify which curve to
   use...  (We should use ecp_use_known_dp() in ctx_alloc() to select a
   particular curve for each ECDH wrapper)




Meeting Notes 7/24 16:54
------------------------

今天看了 ssl_{tls,srv,cli}.c 共一萬多行程式碼中和 DH 比較有關聯的部分
簡直是個悲劇花了六個小時

TODO:
1. Rewrite all DH codes in ssl_{tls,srv,cli}.c
2. Decouple buffer IO and crypto computation
   and then rewrite all DH codes in ssl_{tls,srv,cli}.c again

3. Implement Curve25519 (from NaCl)

Call for meeting Friday (7/25) 14:00~16:00 or 20:00~
for discussing about some of this stuff




Meeting Notes 7/25 14:53
------------------------

Let's do the TODO#2 first

- Marshalling/Unmarhsalling
  Think about how to design the interfaces...

- No need to support all legacy versions
  First try to implement TLS 1.2 well



Meeting Notes 8/05 14:17
------------------------

Trace the code of ECDH.

Q: Does it use two certificates?
Q: Or does it use the same public key for two tasks?
A:
    Only one certificate is needed.
    In TLS, the authentication procedure is done by
    signing the "public" params in DH key exchange.
    No need to sign the whole message before FINISH.

Q: What is the difference between RSA and RSA_PSK?
   ... because we saw in RFC5246:
      Key Exchange Alg.  Certificate Key Type
      RSA                RSA public key; the certificate MUST allow the
      RSA_PSK            key to be used for encryption (the
                         keyEncipherment bit MUST be set if the key
                         usage extension is present).
                         Note: RSA_PSK is defined in [TLSPSK].

我們剛剛讀了一下 RC5246 RFC5246 有了一點結論
1. Server 只需要傳一個 certificate 給 client 即可，該 certificate 保證了 key
   exchange 的訊息是沒有被篡改過的 (signature public key / encryption public key /
   DH public key 三種其一)
2. 除此之外，不需要對整個 handshake 訊息用公鑰簽章；只要有 shared secret 就夠了
   因為在 authenticated encrypted channel 上面，雙方可以比較到此為止所有訊息的
   hash value 即可


TODO
------------------------

PHASE 1

1. (Chen) Write testsuite for DHM
2. (Kuo) Create a wrapper for ECDH using our
         new interface [Finish before 23:59 Wed]
3. (Xian) Write testsuite for ECDH

        For 2. and 3., Try not to call additional mpi_* functions in the
        testing function

PHASE 2

1. Rewrite the SSL codes using the new interface

= Next meeting time 8/8 (Fri) 10:30 am at MD631 =
